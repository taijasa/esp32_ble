{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["totalSize","remaining","amountToWrite","currentPosition","esp32Service","readyFlagCharacteristic","dataToSend","updateData","currentHardwareVersion","softwareVersion","latestCompatibleSoftware","BTConnect","navigator","bluetooth","requestDevice","filters","services","optionalServices","then","device","gatt","connect","server","getPrimaryService","service","_","getCharacteristic","characteristic","readValue","value","getUint8","document","getElementById","innerHTML","fetch","response","json","data","softwareVersionCount","firmware","versionFindLoop","undefined","compatibleHardwareVersion","hardwareVersionCount","console","log","Popup","create","content","buttons","left","text","action","arrayBuffer","close","byteLength","startNotifications","addEventListener","SendBufferedData","catch","error","SendFileOverBluetooth","err","warn","right","CheckVersion","slice","RecursiveSend","writeValue","toPrecision","App","className","id","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.b7ba063a.chunk.js","sourcesContent":["  \n/*************************************************** \n This is a React WebApp written to Flash an ESP32 via BLE\n \n Written by Andrew England (SparkFun)\n BSD license, all text above must be included in any redistribution.\n *****************************************************/\n \n import React from 'react';\nimport Popup from 'react-popup';\nimport './App.css';\n\nvar myESP32 = 'd804b643-6ce7-4e81-9f8a-ce0f699085eb'\n\nvar otaServiceUuid = 'c8659210-af91-4ad3-a995-a58d6fd26145'\nvar versionCharacteristicUuid = 'c8659212-af91-4ad3-a995-a58d6fd26145'\nvar fileCharacteristicUuid = 'c8659211-af91-4ad3-a995-a58d6fd26145'\n\nlet esp32Device = null;\nlet esp32Service = null;\nlet readyFlagCharacteristic = null;\nlet dataToSend = null;\nlet updateData = null;\n\nvar totalSize;\nvar remaining;\nvar amountToWrite;\nvar currentPosition;\n\nvar currentHardwareVersion = \"N/A\";\nvar softwareVersion = \"N/A\";\nvar latestCompatibleSoftware = \"N/A\";\n\nconst characteristicSize = 512;\n\n/* BTConnect\n * Brings up the bluetooth connection window and filters for the esp32\n */\nfunction BTConnect(){\n  navigator.bluetooth.requestDevice({\n    filters: [{\n      services: [myESP32]\n    }],\n    optionalServices: [otaServiceUuid]\n  })\n  .then(device => {\n    return device.gatt.connect()\n  })\n  .then(server => server.getPrimaryService(otaServiceUuid))\n  .then(service => {\n    esp32Service = service;\n  })\n  .then(service => {\n    return service;\n  })\n  .then(_ => {\n    return CheckVersion();\n  })\n  .catch(error => { console.log(error); });\n}\n\n/* onDisconnected(event)\n * If the device becomes disconnected, prompt the user to reconnect.\n */\nfunction onDisconnected(event) {\n  Popup.create({\n    content: esp32Device.name + ' is disconnected, would you like to reconnect?',\n    buttons: {\n      left: [{\n          text: 'Yes',\n          action: function () {\n            Popup.close();\n            BTConnect();\n          }\n      }],\n      right: [{\n          text: 'No',\n          action: function () {\n            Popup.close();\n          }\n      }]\n    }\n  })\n}\n\n/* CheckVersion()\n * Grab most current version from Github and Server, if they don't match, prompt the user for firmware update\n */\nfunction CheckVersion(){\n  if(!esp32Service)\n  {\n    return;\n  }\n  return esp32Service.getCharacteristic(versionCharacteristicUuid)\n  .then(characteristic => characteristic.readValue())\n  .then(value => {\n    currentHardwareVersion = 'v' + value.getUint8(0) + '.' + value.getUint8(1);\n    softwareVersion = 'v' + value.getUint8(2) + '.' + value.getUint8(3) + '.' + value.getUint8(4);\n    document.getElementById('hw_version').innerHTML = \"Hardware: \" + currentHardwareVersion;\n    document.getElementById('sw_version').innerHTML = \"Software: \" + softwareVersion;\n  })\n  //Grab our version numbers from Github\n  .then(_ => fetch('https://raw.githubusercontent.com/sparkfun/ESP32_OTA_BLE_React_WebApp_Demo/master/GithubRepo/version.json'))\n  .then(function (response) {\n    // The API call was successful!\n    return response.json();\n  })\n  .then(function (data) {\n    // JSON should be formatted so that 0'th entry is the newest version\n    if (latestCompatibleSoftware === softwareVersion)\n    {\n      //Software is updated, do nothing.\n    }\n    else {\n      var softwareVersionCount = 0;\n      latestCompatibleSoftware = data.firmware[softwareVersionCount]['software'];\n      versionFindLoop:\n        while (latestCompatibleSoftware !== undefined) {\n          var compatibleHardwareVersion = \"N/A\"\n          var hardwareVersionCount = 0;\n          while (compatibleHardwareVersion !== undefined) {\n            compatibleHardwareVersion = data.firmware[softwareVersionCount]['hardware'][hardwareVersionCount++];\n            if (compatibleHardwareVersion === currentHardwareVersion)\n            {\n              latestCompatibleSoftware = data.firmware[softwareVersionCount]['software'];\n              if (latestCompatibleSoftware !== softwareVersion)\n              {\n                console.log(latestCompatibleSoftware);\n                PromptUserForUpdate();\n              }\n              break versionFindLoop;\n            }\n          }\n          softwareVersionCount++;\n        }\n      }\n  })\n  .catch(error => { console.log(error); });\n}\n\n/* PromptUserForUpdate()\n * Asks the user if they want to update, if yes downloads the firmware based on the hardware version and latest software version and begins sending\n */\nfunction PromptUserForUpdate(){\n    Popup.create({\n      content: \"Version \" + softwareVersion + \" is out of date. Update to \" + latestCompatibleSoftware + \"?\",\n      buttons: {\n          left: [{\n              text: 'Yes',\n              action: function () {\n                fetch('https://raw.githubusercontent.com/sparkfun/ESP32_OTA_BLE_React_WebApp_Demo/' + latestCompatibleSoftware + '/GithubRepo/' + currentHardwareVersion + '.bin')\n                .then(function (response) {\n                  return response.arrayBuffer();\n                })\n                .then(function (data) {\n                  Popup.close();\n                  \n                  updateData = data;\n                  return SendFileOverBluetooth();\n                })\n                .catch(function (err) { console.warn('Something went wrong.', err); });\n              }\n          }],\n          right: [{\n              text: 'No',\n              action: function () {\n                Popup.close();\n              }\n          }]\n      }\n  })\n}\n\n/* SendFileOverBluetooth(data)\n * Figures out how large our update binary is, attaches an eventListener to our dataCharacteristic so the Server can tell us when it has finished writing the data to memory\n * Calls SendBufferedData(), which begins a loop of write, wait for ready flag, write, wait for ready flag...\n */\nfunction SendFileOverBluetooth() {\n  if(!esp32Service)\n  {\n    console.log(\"No esp32 Service\");\n    return;\n  }\n\n  totalSize = updateData.byteLength;\n  remaining = totalSize;\n  amountToWrite = 0;\n  currentPosition = 0;\n  esp32Service.getCharacteristic(fileCharacteristicUuid)\n  .then(characteristic => {\n    readyFlagCharacteristic = characteristic;\n    return characteristic.startNotifications()\n    .then(_ => {\n      readyFlagCharacteristic.addEventListener('characteristicvaluechanged', SendBufferedData)\n    });\n  })\n  .catch(error => { \n    console.log(error); \n  });\n  SendBufferedData();\n}\n\n\n/* SendBufferedData()\n * An ISR attached to the same characteristic that it writes to, this function slices data into characteristic sized chunks and sends them to the Server\n */\nfunction SendBufferedData() {\n  if (remaining > 0) {\n    if (remaining >= characteristicSize) {\n      amountToWrite = characteristicSize\n    }\n    else {\n      amountToWrite = remaining;\n    }\n    dataToSend = updateData.slice(currentPosition, currentPosition + amountToWrite);\n    currentPosition += amountToWrite;\n    remaining -= amountToWrite;\n    console.log(\"remaining: \" + remaining);\n    esp32Service.getCharacteristic(fileCharacteristicUuid)\n      .then(characteristic => RecursiveSend(characteristic, dataToSend))\n      .then(_ => {\n        return document.getElementById('completion').innerHTML = (100 * (currentPosition/totalSize)).toPrecision(3) + '%';\n      })\n      .catch(error => { \n        console.log(error); \n      });\n  }\n}\n\n\n/* resursiveSend()\n * Returns a promise to itself to ensure data was sent and the promise is resolved.\n */\nfunction RecursiveSend(characteristic, data) {\n  return characteristic.writeValue(data)\n  .catch(error => {\n    return RecursiveSend(characteristic, data);\n  });\n}\n\n\n/* App()\n * The meat and potatoes of our web-app; where it all comes together\n */\nfunction App() {\nreturn (\n<div className=\"App\" id=\"top\">\n  <header className=\"App-header\" id=\"mid\">\n    <Popup />\n    <p id=\"hw_version\">Hardware: Not Connected</p>\n    <p id=\"sw_version\">Software: Not Connected</p>\n    <p id=\"completion\"></p>\n    <button id=\"connect\"\n    onClick={BTConnect}\n    >\n      Connect to Bluetooth\n    </button>\n  </header>\n</div>\n)\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />    \n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}